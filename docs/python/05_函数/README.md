## 函数简介（function）

函数名可以包含字母、数字、下划线开头、但是不能以数字开头
语法:
```
def 函数名([形参1,形参2,...形参n]) :
            代码块
```

   

## 函数的参数
 
+ 函数在调用时，解析器不会检查实参的类型
+ 实参可以传递任意类型的对象  

```python
def fn(a = 1 , b = 10 , c = 5):
    print('a =',a)
    print('b =',b)
    print('c =',c)
#调用
fn(b=1 , c=2 , a=3)
fn(1,c=3)
fn()
```
### 不定长参数

  在定义函数时，可以在形参前边加上一个*，这样这个形参将会获取到所有的实参
它将会将所有的实参保存到一个元组中


```python

# *nums会接受所有的位置实参，并且会将这些实参统一保存到一个元组中（装包）
def sum(*nums):
    # 定义一个变量，来保存结果
    result = 0
    # 遍历元组，并将元组中的数进行累加
    for n in nums :
        result += n
    print(result)

sum(123,456,789,10,20,30,40)
  
```
可变参数不是必须写在最后，但是注意，带*的参数后的所有参数，必须以关键字参数的形式传递
 第一个参数给a，剩下的位置参数给b的元组，c必须使用关键字参数

```python
def fn2(a,*b,c):
    print('a =',a)
    print('b =',b)
    print('c =',c)
```
  
  如果在形参的开头直接写一个*,则要求我们的所有的参数必须以关键字参数的形式传递

```python
def fn2(*,a,b,c):
    print('a =',a)
    print('b =',b)
    print('c =',c)
fn2(a=3,b=4,c=5)
```


 形参只能接收位置参数，而不能接收关键字参数
```python
def fn3(*a) :
     print('a =',a)
```


 `**`形参可以接收其他的关键字参数，它会将这些参数统一保存到一个字典中
   字典的key就是参数的名字，字典的value就是参数的值
 `**`形参只能有一个，并且必须写在所有参数的最后



```python

def fn3(b,c,**a) :
    print('a =',a,type(a)) #a = {'d': 2, 'e': 10, 'f': 20} <class 'dict'>
    print('b =',b) # b =1 
    print('c =',c) #c = 3

fn3(b=1,d=2,c=3,e=10,f=20)

```


###  参数的解包（拆包）


```python
def fn4(a,b,c):
    print('a =',a)
    print('b =',b)
    print('c =',c)
# 创建一个元组
t = (10,20,30)
# 传递实参时，也可以在序列类型的参数前添加星号，这样他会自动将序列中的元素依次作为参数传递
# 这里要求序列中元素的个数必须和形参的个数的一致
# fn4(*t)    

# 创建一个字典
d = {'a':100,'b':200,'c':300}
# 通过 **来对一个字典进行解包操作
fn4(**d)
```


## 返回值

+ return 后边跟什么值，函数就会返回什么值
+ return 后边可以跟任意的对象，返回值甚至可以是一个函数
+ 仅仅写一个return 或者 不写return，则相当于return None 





## 文档字符串（doc str）

+ 在定义函数时，可以在函数内部编写文档字符串，文档字符串就是函数的说明
+ 当我们编写了文档字符串时，就可以通过help()函数来查看函数的说明
+ 文档字符串非常简单，其实直接在函数的第一行写一个字符串就是文档字符串

```python
def fn(a:int,b:bool,c:str='hello') -> int:
    '''
    这是一个文档字符串的示例

    函数的作用：。。。。。
    函数的参数：
        a，作用，类型，默认值。。。。
        b，作用，类型，默认值。。。。
        c，作用，类型，默认值。。。。
    '''
    return 10
```
 
  通过help()函数可以查询python中的函数的用法

```python
#语法：help(函数对象)
help(print)  
help(fn)
```


## 变量的作用域

```python
a = 1 #全局变量
def fn():
    # a = 10 # 在函数中为变量赋值时，默认都是为局部变量赋值
    # 如果希望在函数内部修改全局变量，则需要使用global关键字，来声明变量
    global a # 声明在函数内部的使用a是全局变量，此时再去修改a时，就是在修改全局的a
    a = 10 # 修改全局变量
    print('函数内部：','a =',a)
```
## 命名空间（namespace）

+ 命名空间指的是变量存储的位置，每一个变量都需要存储到指定的命名空间当中
+ 每一个作用域都会有一个它对应的命名空间
+ 全局命名空间，用来保存全局变量。函数命名空间用来保存函数中的变量
+ 命名空间实际上就是一个字典，是一个专门用来存储变量的字典
+ locals()用来获取当前作用域的命名空间
+ 如果在全局作用域中调用locals()则获取全局命名空间，如果在函数作用域中调用locals()则获取函数命名空间
+ 返回的是一个字典

+ globals() 函数可以用来在任意位置获取全局命名空间


## 高阶函数

+ 高阶函数至少要符合以下两个特点中的一个
    1. 接收一个或多个函数作为参数
    2. 将函数作为返回值返回
 

### filter()
 可以从序列中过滤出符合条件的元素，保存到一个新的序列中
 - 参数：
   1. 函数，根据该函数来过滤序列（可迭代的结构）()bool
   2. 需要过滤的序列（可迭代的结构         
    
### lambda        
 
```python
# 也可以将匿名函数赋值给一个变量，一般不会这么做
fn6 = lambda a,b : a + b
print(fn6(10,30))
print()


r = filter(lambda i : i > 5 , l)
print(list(r))

```

### map()

map()函数可以对可跌倒对象中的所有元素做指定的操作，然后将其添加到一个新的对象中返回

```python


l = [1,2,3,4,5,6,7,8,9,10]

r = map(lambda i : i ** 2 , l) 
print(list(r)#[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
```

### sort()

sort()方法默认是直接比较列表中的元素的大小

### sorted()

这个函数和sort()的用法基本一致，但是sorted()可以对任意的序列进行排序
   并且使用sorted()排序不会影响原来的对象，而是返回一个新对象


## 闭包
 将函数作为返回值返回，也是一种高阶函数。
 这种高阶函数我们也称为叫做闭包，通过闭包可以创建一些只有当前函数能访问的变量。
   可以将一些私有的数据藏到的闭包中。

> 形成闭包的要件
> 1. 函数嵌套
>   2. 将内部函数作为返回值返回
>   3. 内部函数必须要使用到外部函数的变量

```python
def fn():
    a = 10
    # 函数内部再定义一个函数
    def inner():
        print('我是fn2' , a)

    # 将内部函数 inner作为返回值返回   
    return inner

# r是一个函数，是调用fn()后返回的函数
# 这个函数实在fn()内部定义，并不是全局函数
# 所以这个函数总是能访问到fn()函数内的变量
r = fn()    
r()
```


## 装饰器

 通过装饰器，可以在不修改原来函数的情况下来对函数进行扩展.
 在定义函数时，可以通过@装饰器，来使用指定的装饰器，来装饰当前的函数.
   可以同时为一个函数指定多个装饰器，这样函数将会安装从内向外的顺序被装饰 .
```python
# 像fn3()这种函数我们就称它为装饰器
def fn3(old):
    '''
        用来对其他函数进行扩展，使其他函数可以在执行前打印开始执行，执行后打印执行结束

        参数：
            old 要扩展的函数对象
    '''
    # 创建一个新函数
    def new_function(*args , **kwargs):
        print('fn3装饰~开始执行~~~~')
        # 调用被扩展的函数
        result = old(*args , **kwargs)
        print('fn3装饰~执行结束~~~~')
        # 返回函数的执行结果
        return result

    # 返回新函数        
    return new_function

@fn3
def say_hello():
    print('大家好~~~')

say_hello()


```
